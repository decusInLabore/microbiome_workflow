---
title: "Bulk RNA-Seq Read Coverage Plot Module"
author: "Stefan Boeing stefan.boeing@crick.ac.uk"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
    html_document:
        code_folding: hide
        df_print: tibble
        toc: true
        toc_depth: 5
        toc_float: true
        css:

always_allow_html: yes

---

```{css setup_css, echo=FALSE}


.table{
  width:auto;
  font-size: 10px;
}

```

```{r setup, include=FALSE}
###############################################################################
## Recommended R-version                                                     ##

# module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/4.0.3-foss-2020a;R

## Done                                                                      ##
###############################################################################




###############################################################################
## Set the environment                                                       ##

# if (!require("remotes")){
#   install.packages("remotes")
# }
# 
# remotes::install_github("rstudio/renv")

if (!file.exists("renv.lock")){
    renv::init()
} else {
    renv::restore(prompt=FALSE)
}

#renv::install("decusinlabore/biologicSeqTools2)
#renv::install("bioc::ensembldb")
#renv::install("bioc::DESeq2")
#renv::install("bioc::clusterProfiler")
#renv

## Done                                                                      ##
###############################################################################


###############################################################################
## Set knitr options                                                         ##

knitr::opts_chunk$set(
    tidy = F,
    tidy.opts = list(width.cutoff = 120),
    message = FALSE,
    warning = FALSE
)

##                                                                           ##
###############################################################################

###############################################################################
## Set global variables                                                      ##

workdir <- gsub("scripts/bulkRNAseq_workflow/analyses/Read_Coverage_Plots","workdir/",getwd())
projectDir <-  gsub("scripts/bulkRNAseq_workflow/analyses/Read_Coverage_Plots" ,"",getwd())
dataDir <- paste0(projectDir, "data/")

figureCount <- 1
tableCount <- 1
upload.results.to.database <- TRUE
shinyBaseServerURL <- "shiny-bioinformatics.crick.ac.uk"

## Done                                                                      ##
###############################################################################


###############################################################################
## Load biologic object from part A                                          ##
library(biologicSeqTools2)

biologicDir <- paste0(dataDir, "biologic_active_object/")

FN <- paste0(biologicDir,list.files(biologicDir)[grep("bioLOGIC.Robj", list.files(biologicDir))])
load(FN)
## Done                                                                      ##
###############################################################################

```

```{r set_directories, eval=T}
## Setup plot collection object
library(knitr)
library(ggplot2)
#library(ggpubr)
#library(DT)


geneCoveragePlotVec <- c("DMRT1", "FOXL2", "SOX9")


figureCount <- 1
chnkVec <- as.vector(NULL, mode = "character")

VersionPdfExt <- paste0(".V", gsub("-", "", Sys.Date()), ".pdf")

if (dir.exists("/Volumes/babs/working/boeings/")){
    hpc.mount <- "/Volumes/babs/working/boeings/"
} else if (dir.exists("Y:/working/boeings/")){
    hpc.mount <- "Y:/working/boeings/"
} else if (dir.exists("/camp/stp/babs/working/boeings/")){
    hpc.mount <- "/camp/stp/babs/working/boeings/"
} else {
    hpc.mount <- ""
}


if (length(.libPaths()) > 2){
    .libPaths(.libPaths()[2:3])
}







## Loading the BABS password ##
if (Obio@parameterList[["upload.results.to.database"]]){
    FN <- paste0(hpc.mount, "Projects/reference_data/pwd_folder/babs.txt")
    dbTable <- read.delim(
      FN,
      header = F,
      sep = "\t",
      stringsAsFactors = F
    )
}

 Obio@dbDetailList[["db.pwd"]] <- as.vector(dbTable[1,1])


# Obio <- biologicSeqTools2::setMountingPoint(Obio)
# Obio <- biologicSeqTools2::setAnalysisPaths(Obio)
# Obio <- biologicSeqTools2::setCrickGenomeAndGeneNameTable(Obio)
# Obio <- biologicSeqTools2::createAnalysisFolders(
#     Obio #,
#     #baseDir="/camp/stp/babs/working/boeings/Projects/",
#     #localBaseDir = paste0(hpc.mount, "Projects/")
# )
# Obio <- biologicSeqTools2::setDataBaseParameters(Obio)


# Obio@parameterList[["reportFigDir"]] <- paste0(Obio@parameterList$workdir,Obio@parameterList$project_id, "/report_figures/")
# 
# ## Create outputfolders ##
# if (!dir.exists(paste0(Obio@parameterList$workdir,Obio@parameterList$project_id))){
#     dir.create(paste0(Obio@parameterList$workdir,Obio@parameterList$project_id))
# }
# 
# if (!dir.exists(Obio@parameterList$reportFigDir)){
#     dir.create(Obio@parameterList$reportFigDir)
# }

figureCount <- 1
```

## Create Reference

```{r create_bigwig2, echo=T, eval=TRUE, warning=FALSE, result=F, warning= F, include = F}

#library(biomaRt)

species <- Obio@parameterList$species

species <- unlist(strsplit(species, "_"))
species[1] <- substr(species[1], 1, 1)
selString <- paste0(species, collapse = "") 
selString <- paste0(selString, "_gene_ensembl")

if (is.null(Obio@parameterList$release)){
    release <- 95
} else {
    release <- Obio@parameterList$release
}

releaseID <- gsub("release-", "", tolower(release))

## Lookup biomart url
lookupTable <- biomaRt::listEnsemblArchives()
lookupTable <- lookupTable[lookupTable$version  == releaseID, ]

if (nrow(lookupTable) > 0){
    biomartURL <- as.vector(lookupTable[1,"url"])
} else {
    stop("No ensembl biomart table available for this release.")
}


primaryAlignmentGeneID <- Obio@parameterList$primaryAlignmentGeneID
geneIDcolumn <- Obio@parameterList$geneIDcolumn


ensembl_mart = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host = biomartURL)

if (Obio@parameterList$species == "mus_musculus"){
    selString <- "mmusculus"
} else if (Obio@parameterList$species == "homo_sapiens") {
   selString <- "hsapiens"
} else if (Obio@parameterList$species == "gallus_gallus") {
   selString <- "ggallus"
} else{
    stop()
}


ensembl_dataset = biomaRt::useDataset(paste0(selString, "_gene_ensembl"),mart=ensembl_mart)

#print(ensembl_dataset)

selected_attributes = c("ensembl_transcript_id", "ensembl_gene_id", 
                        "external_gene_name", "strand", "chromosome_name", "start_position", "end_position", 
                        "gene_biotype", "transcript_biotype")
data = biomaRt::getBM(attributes = selected_attributes, mart = ensembl_dataset)
#head(data)

data = dplyr::rename(data, 
                     transcript_id = ensembl_transcript_id, 
                     gene_id = ensembl_gene_id, 
                     gene_name = external_gene_name)
#head(data)

temporary_file = tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rds")
saveRDS(data, temporary_file)

transcript_metadata = readRDS(temporary_file)
#head(transcript_metadata)

## Download txDB

## Create gene annotation if it is not present ##
## To be activated ##

species <- Obio@parameterList$species

species <- unlist(strsplit(species, "_"))
species[1] <- substr(species[1], 1, 1)
selString <- paste0(species, collapse = "") 
selString <- paste0(selString, "_gene_ensembl")

if (is.null(Obio@parameterList$release)){
    release <- 95
} else {
    release <- Obio@parameterList$release
}

releaseID <- gsub("release-", "", tolower(release))

## Lookup biomart url
lookupTable <- biomaRt::listEnsemblArchives()
lookupTable <- lookupTable[lookupTable$version  == releaseID, ]

if (nrow(lookupTable) > 0){
    biomartURL <- as.vector(lookupTable[1,"url"])
    biomartURL <- gsub("https:", "http:", biomartURL)
} else {
    stop("No ensembl biomart table available for this release.")
}


txdb = GenomicFeatures::makeTxDbFromBiomart(
    biomart = "ENSEMBL_MART_ENSEMBL", 
    dataset = selString, 
    host=biomartURL
)



txdb_file = tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rds")
AnnotationDbi::saveDb(txdb, txdb_file)

txdb = AnnotationDbi::loadDb(txdb_file)

exons = ensembldb::exonsBy(txdb, by = "tx", use.names = T)
cdss = ensembldb::cdsBy(txdb, by = "tx", use.names = T)


```


```{r set_region_var, eval=T}
## Setup plot collection object




## Load R module load R/3.5.1-foss-2018b ##
#setwd(Obio@parameterList$workdir)
#######
## Function plotCoverage from wiggleplotR.r
#' Quickly plot transcript structure without read coverage tracks
#'
#' @param exons list of GRanges objects, each object containing exons for one transcript.
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame.
#' @param cdss list of GRanges objects, each object containing the coding regions (CDS) of a single transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame. 
#' If cdss is not specified then exons list will be used for both arguments. (default: NULL)
#' @param transcript_annotations Data frame with at least three columns: transcript_id, gene_name, strand.
#' Used to construct transcript labels. (default: NULL)
#' @param rescale_introns Specifies if the introns should be scaled to fixed length or not. (default: TRUE)
#' @param new_intron_length length (bp) of introns after scaling. (default: 50)
#' @param flanking_length Lengths of the flanking regions upstream and downstream of the gene. (default: c(50,50))
#' @param connect_exons Print lines that connect exons together. Set to FALSE when plotting peaks (default: TRUE).
#' @param transcript_label If TRUE then transcript labels are printed above each transcript. (default: TRUE). 
#' @param region_coords Start and end coordinates of the region to plot, overrides flanking_length parameter.
#'
#' @return ggplot2 object
#' @examples
#' plotTranscripts(ncoa7_exons, ncoa7_cdss, ncoa7_metadata, rescale_introns = FALSE)
#' 
#' @export

joinExons <- function(exons) {
  #Join a list of exons into one GRanges object
  
  #Test that all transcripts are on the same chromosome
  chrs = purrr::map_chr(as.list(exons), ~GenomicRanges::seqnames(.)[1] %>% 
                              S4Vectors::as.vector.Rle(mode = "character"))
  if (!all(chrs == chrs[1])){
    stop("Some transcripts are on different chromosomes.")
  }
  
  #Join all exons together
  transcript_ids = names(exons)
  joint_exons = c()
  for(tx_id in transcript_ids){
    tx = exons[[tx_id]]
    if(length(joint_exons) == 0){
      joint_exons = tx
    }
    else{
      joint_exons = c(joint_exons, tx)
    }
  }
  joint_exons = GenomicRanges::reduce(joint_exons)
  return(joint_exons)
}

extractStrandsFromGrangesList <- function(granges_list){
  strands = purrr::map(as.list(granges_list), ~(GenomicRanges::strand(.) %>%
                         S4Vectors::as.vector.Rle(.,"character"))[1])
  return(unlist(strands))
}


prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}


prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}


plotTranscripts <- function(exons, cdss = NULL, transcript_annotations = NULL, 
                            rescale_introns = TRUE, new_intron_length = 50, 
                            flanking_length = c(50,50), connect_exons = TRUE, 
                            transcript_label = TRUE, region_coords = NULL){
  
  #IF cdss is not specified then use exons instead on cdss
  if(is.null(cdss)){
    cdss = exons
  }
  
  #Check exons and cdss
  assertthat::assert_that(is.list(exons)|| is(exons, "GRangesList")) #Check that exons and cdss objects are lists
  assertthat::assert_that(is.list(cdss) || is(exons, "GRangesList"))
  
  #Join exons together
  joint_exons = joinExons(exons)
  
  #Extract chromosome name
  chromosome_name = as.vector(GenomicRanges::seqnames(joint_exons)[1])
  
  #If region_coords is specificed, then ignore the flanking_length attrbute and compute
  # flanking_length form region_coords
  if(!is.null(region_coords)){
    gene_range = constructGeneRange(joint_exons, c(0,0))
    min_start = min(GenomicRanges::start(gene_range))
    max_end = max(GenomicRanges::end(gene_range))
    flanking_length = c(min_start - region_coords[1], region_coords[2] - max_end)
  }
  #Make sure that flanking_length is a vector of two elements
  assertthat::assert_that(length(flanking_length) == 2) 

  #Rescale introns
  if (rescale_introns){
    tx_annotations = rescaleIntrons(exons, cdss, joint_exons, new_intron_length = new_intron_length, flanking_length)
    xlabel = "Distance from region start (bp)"
  } else {
    old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
    tx_annotations = list(exon_ranges = lapply(exons, GenomicRanges::ranges), cds_ranges = lapply(cdss, GenomicRanges::ranges),
                          old_introns = old_introns, new_introns = old_introns)
    
    xlabel = paste("Chromosome", chromosome_name, "position (bp)")
  }
  
  #If transcript annotations are not supplied then construct them manually from the GRanges list
  if(is.null(transcript_annotations)){
    plotting_annotations = dplyr::tibble(transcript_id = names(exons),
                                             strand = extractStrandsFromGrangesList(exons)) %>%
      prepareTranscriptAnnotations()
  } else{
    plotting_annotations = prepareTranscriptAnnotations(transcript_annotations)
  }
  
  #Plot transcript structures
  limits = c( min(IRanges::start(tx_annotations$new_introns)), max(IRanges::end(tx_annotations$new_introns)))
  structure = prepareTranscriptStructureForPlotting(tx_annotations$exon_ranges, 
                                               tx_annotations$cds_ranges, plotting_annotations)
  plot = plotTranscriptStructure(structure, limits, connect_exons = connect_exons, xlabel = xlabel, 
                                 transcript_label = transcript_label)
  return(plot)
}

#' Plot read coverage across genomic regions
#' 
#' Also supports rescaling introns to constant length. Does not work 
#' on Windows, because rtracklayer cannot read BigWig files on Windows.
#' 
#' @param exons list of GRanges objects, each object containing exons for one transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame.
#' @param cdss list of GRanges objects, each object containing the coding regions (CDS) of a single transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame. 
#' If cdss is not specified then exons list will be used for both arguments. (default: NULL).
#' @param transcript_annotations Data frame with at least three columns: transcript_id, gene_name, strand. 
#' Used to construct transcript labels. (default: NULL)
#' @param track_data data.frame with the metadata for the bigWig read coverage files. Must contain the following columns:
#' \itemize{
#'  \item sample_id - unique id for each sample.
#'  \item track_id - if multiple samples (bigWig files) have the same track_id they will be overlayed on the same 
#' plot, track_id is also used as the facet label on the right.
#'  \item bigWig - path to the bigWig file.
#'  \item scaling_factor - normalisation factor for each sample, useful if different samples sequenced to different 
#' depth and bigWig files not normalised for that.
#'  \item colour_group - additional column to group samples into, is used as the colour of the coverage track.
#' }
#' @param rescale_introns Specifies if the introns should be scaled to fixed length or not. (default: TRUE)
#' @param new_intron_length length (bp) of introns after scaling. (default: 50)
#' @param flanking_length Lengths of the flanking regions upstream and downstream of the gene. (default: c(50,50))
#' @param plot_fraction Size of the random sub-sample of points used to plot coverage (between 0 and 1). 
#' Smaller values make plotting significantly faster. (default: 0.1)
#' @param heights  Specifies the proportion of the height that is dedicated to coverage plots (first value) 
#' relative to transcript annotations (second value). (default: c(0.75,0.25))
#' @param alpha Transparency (alpha) value for the read coverage tracks. 
#' Useful to set to something < 1 when overlaying multiple tracks (see track_id). (default: 1)
#' @param fill_palette Vector of fill colours used for the coverage tracks. Length must be equal to the number of 
#' unique values in track_data$colour_group column.
#' @param mean_only Plot only mean coverage within each combination of track_id and colour_group values. 
#' Useful for example for plotting mean coverage stratified by genotype (which is specified in the colour_group column) (default: TRUE).
#' @param connect_exons Print lines that connect exons together. Set to FALSE when plotting peaks (default: TRUE).
#' @param transcript_label If TRUE then transcript labels are printed above each transcript. (default: TRUE). 
#' @param return_subplots_list Instead of a joint plot return a list of subplots that can be joined together manually. 
#' @param region_coords Start and end coordinates of the region to plot, overrides flanking_length parameter.
#' @param coverage_type Specifies if the read coverage is represented by either 'line', 'area' or 'both'. 
#' The 'both' option tends to give better results for wide regions. (default: area). 
#'
#' @return Either object from cow_plot::plot_grid() function or a list of subplots (if return_subplots_list == TRUE)
#' @examples
#' require("dplyr")
#' require("GenomicRanges")
#' sample_data = dplyr::data_frame(sample_id = c("aipt_A", "aipt_C", "bima_A", "bima_C"), 
#'     condition = factor(c("Naive", "LPS", "Naive", "LPS"), levels = c("Naive", "LPS")), 
#'     scaling_factor = 1) %>%
#'     dplyr::mutate(bigWig = system.file("extdata",  paste0(sample_id, ".str2.bw"), package = "wiggleplotr"))
#' 
#' track_data = dplyr::mutate(sample_data, track_id = condition, colour_group = condition)
#' 
#' selected_transcripts = c("ENST00000438495", "ENST00000392477") #Plot only two transcripts of the gens
#' \dontrun{
#' plotCoverage(ncoa7_exons[selected_transcripts], ncoa7_cdss[selected_transcripts], 
#'    ncoa7_metadata, track_data, 
#'    heights = c(2,1), fill_palette = getGenotypePalette())
#' }
#' 
#' @export
plotCoverage <- function(exons, cdss = NULL, transcript_annotations = NULL, track_data, rescale_introns = TRUE,
                        new_intron_length = 50, flanking_length = c(50,50),
                        plot_fraction = 0.1, heights = c(0.75, 0.25), alpha = 1,
                        fill_palette = c("#a1dab4","#41b6c4","#225ea8"), mean_only = TRUE, 
                        connect_exons = TRUE, transcript_label = TRUE, return_subplots_list = FALSE,
                        region_coords = NULL, coverage_type = "area"){
  
  #IF cdss is not specified then use exons instead on cdss
  if(is.null(cdss)){
    cdss = exons
  }
  
  #Make some assertions about the input data
  #Check track_data
  assertthat::assert_that(assertthat::has_name(track_data, "sample_id"))
  assertthat::assert_that(assertthat::has_name(track_data, "track_id"))
  assertthat::assert_that(assertthat::has_name(track_data, "bigWig"))
  assertthat::assert_that(assertthat::has_name(track_data, "scaling_factor"))
  assertthat::assert_that(assertthat::has_name(track_data, "colour_group"))
  
  #Make sure that bigWig column is not a factor
  if(is.factor(track_data$bigWig)){
    warning("bigWig column in track_data data.frame is a factor, coverting to a character vector.")
    track_data = dplyr::mutate_(track_data, .dots = stats::setNames(list(~as.character(bigWig)), c("bigWig")))
  }
  
  #Check transcript annotation
  #If transcript annotations are not supplied then construct them manually from the GRanges list
  if(is.null(transcript_annotations)){
    plotting_annotations = dplyr::data_frame(transcript_id = names(exons),
                                             strand = extractStrandsFromGrangesList(exons)) %>%
      prepareTranscriptAnnotations()
  } else{
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "gene_name"))
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
    plotting_annotations = prepareTranscriptAnnotations(transcript_annotations)
  }
  
  #Check exons and cdss
  assertthat::assert_that(is.list(exons) || is(exons, "GRangesList")) #Check that exons and cdss objects are lists
  assertthat::assert_that(is.list(cdss) || is(exons, "GRangesList"))
  #TODO: Check that the names of the exons and cdss list match that of the transcript_annotations data.frame
  
  #Find the start and end cooridinates of the whole region spanning the gene
  joint_exons = joinExons(exons)
  
  #If region_coords is specificed, then ignore the flanking_length attrbute and compute
  # flanking_length form region_coords
  if(!is.null(region_coords)){
    gene_range = constructGeneRange(joint_exons, c(0,0))
    min_start = min(GenomicRanges::start(gene_range))
    max_end = max(GenomicRanges::end(gene_range))
    flanking_length = c(min_start - region_coords[1], region_coords[2] - max_end)
    
    gene_range = constructGeneRange(joint_exons, flanking_length)
  } else{
    gene_range = constructGeneRange(joint_exons, flanking_length)
  }
  assertthat::assert_that(length(flanking_length) == 2) #flanking_length is a vector of two elements

  #Extract chromosome name
  chromosome_name = as.vector(GenomicRanges::seqnames(gene_range)[1])

  #Read coverage tracks from BigWig file
  sample_list = as.list(track_data$bigWig)
  names(sample_list) = track_data$sample_id
  coverage_list = lapply(sample_list, readCoverageFromBigWig, gene_range)

  #Shorten introns and translate exons into the new introns
  if(rescale_introns){
    #Recale transcript annotations
    tx_annotations = rescaleIntrons(exons, cdss, joint_exons, 
                                    new_intron_length = new_intron_length, flanking_length = flanking_length)
    #Make a label for gene structure plot
    xlabel = "Distance from region start (bp)"
  }
  else{ #Do not rescale transcript annotationn
    #Need to calculate joint intron coordinates for transcript annotations
    old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
    tx_annotations = list(exon_ranges = lapply(exons, GenomicRanges::ranges), cds_ranges = lapply(cdss, GenomicRanges::ranges),
                          old_introns = old_introns, new_introns = old_introns)
    
    #Make a label for gene structure plot
    xlabel = paste("Chromosome", chromosome_name, "position (bp)")
  }
  #Shrink intron coverage and convert coverage vectors into data frames
  coverage_list = lapply(coverage_list, shrinkIntronsCoverage, tx_annotations$old_introns, tx_annotations$new_introns)

  #Take a subsample of points that is easier to plot
  points = subsamplePoints(tx_annotations, plot_fraction)
  coverage_list = lapply(coverage_list, function(x) {x[points,]} )

  #Convert to data frame and plot
  coverage_df = purrr::map_df(coverage_list, identity, .id = "sample_id") %>% 
    as.data.frame() %>%
    dplyr::mutate_(.dots = stats::setNames(list(~as.character(sample_id)), c("sample_id")) ) #Convert factor to character
  coverage_df = dplyr::left_join(coverage_df, track_data, by = "sample_id") %>%
    dplyr::mutate_(.dots = stats::setNames(list(~coverage/scaling_factor), c("coverage")) ) #Normalize by library size

  #Calculate mean coverage within each track and colour group
  if(mean_only){  coverage_df = meanCoverage(coverage_df) }
  
  #Make plots
  #Construct transcript structure data.frame from ranges lists
  limits = c( min(IRanges::start(tx_annotations$new_introns)), max(IRanges::end(tx_annotations$new_introns)))
  transcript_struct = prepareTranscriptStructureForPlotting(tx_annotations$exon_ranges, 
                       tx_annotations$cds_ranges, plotting_annotations)
  tx_structure = plotTranscriptStructure(transcript_struct, limits, connect_exons, xlabel, transcript_label)
  
  coverage_plot = makeCoveragePlot(coverage_df, limits, alpha, fill_palette, coverage_type)
  
  #Choose between returning plot list or a joint plot using plot_grid
  if(return_subplots_list){
    plot_list = list(coverage_plot = coverage_plot, tx_structure = tx_structure)
    return(plot_list)
  } else {
    plot = cowplot::plot_grid(coverage_plot, tx_structure, align = "v", rel_heights = heights, ncol = 1)
    return(plot)
  }
}

#Helper function to make wiggle plots

readCoverageFromBigWig <- function(bigwig_path, gene_range){
  #Read coverage over a region from a bigWig file
  sel = rtracklayer::BigWigSelection(gene_range)
  coverage_ranges = rtracklayer::import.bw(bigwig_path, selection = sel)
  GenomeInfoDb::seqlevels(coverage_ranges) = S4Vectors::as.vector.Rle(GenomicRanges::seqnames(gene_range), mode = "character")
  coverage_rle = GenomicRanges::coverage(coverage_ranges, weight = GenomicRanges::score(coverage_ranges))[[1]]
  coverage_rle = coverage_rle[(GenomicRanges::start(gene_range)):(GenomicRanges::end(gene_range))] #Keep the region of interest
}

joinExons <- function(exons) {
  #Join a list of exons into one GRanges object
  
  #Test that all transcripts are on the same chromosome
  chrs = purrr::map_chr(as.list(exons), ~GenomicRanges::seqnames(.)[1] %>% 
                              S4Vectors::as.vector.Rle(mode = "character"))
  if (!all(chrs == chrs[1])){
    stop("Some transcripts are on different chromosomes.")
  }
  
  #Join all exons together
  transcript_ids = names(exons)
  joint_exons = c()
  for(tx_id in transcript_ids){
    tx = exons[[tx_id]]
    if(length(joint_exons) == 0){
      joint_exons = tx
    }
    else{
      joint_exons = c(joint_exons, tx)
    }
  }
  joint_exons = GenomicRanges::reduce(joint_exons)
  return(joint_exons)
}

extractStrandsFromGrangesList <- function(granges_list){
  strands = purrr::map(as.list(granges_list), ~(GenomicRanges::strand(.) %>%
                         S4Vectors::as.vector.Rle(.,"character"))[1])
  return(unlist(strands))
}

prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}

prepareTranscriptStructureForPlotting <- function(exon_ranges, cds_ranges, transcript_annotations){
  #Combine exon_ranges and cds_ranges into a single data.frame that also contains transcript rank
  
  #Convert exon ranges into data.frame and add transcript rank
  exons_df = purrr::map_df(exon_ranges, data.frame, .id = "transcript_id")
  exons_df = dplyr::mutate(exons_df, transcript_rank = as.numeric(factor(exons_df$transcript_id)), type = "")
  transcript_rank = unique(exons_df[,c("transcript_id", "transcript_rank", "type")])
  
  #Convert CDS ranges into a data.frame
  cds_df = purrr::map_df(cds_ranges, data.frame, .id = "transcript_id")
  cds_df = dplyr::left_join(cds_df, transcript_rank, by = "transcript_id") #Add matching transcript rank
  
  #Join exons and cdss together
  exons_df = dplyr::mutate(exons_df, feature_type = "exon")
  cds_df = dplyr::mutate(cds_df, feature_type = "cds")
  transcript_struct = rbind(exons_df, cds_df)

  #Add transcript label to transcript structure
  transcript_struct = dplyr::left_join(transcript_struct, transcript_annotations, by = "transcript_id")
  return(transcript_struct)
}

intronsFromJointExonRanges <- function(joint_exon_ranges, flanking_length){
  #Construct intron ranges from joint exon ranges
  introns = IRanges::gaps(joint_exon_ranges, 
                     start = min(IRanges::start(joint_exon_ranges)) - flanking_length[1], 
                     end = max(IRanges::end(joint_exon_ranges)) + flanking_length[2])
  return(introns)
}

# Find the start and end coordinates of the whole gene form joint exons. 
constructGeneRange <- function(joint_exon_ranges, flanking_length){
  gene_range = GenomicRanges::reduce(c(joint_exon_ranges, GenomicRanges::gaps(joint_exon_ranges, start = NA, end = NA)))
  GenomeInfoDb::seqlevels(gene_range) = S4Vectors::as.vector.Rle(GenomicRanges::seqnames(gene_range), mode = "character")[1]
  GenomicRanges::start(gene_range) = GenomicRanges::start(gene_range) - flanking_length[1]
  GenomicRanges::end(gene_range) = GenomicRanges::end(gene_range) + flanking_length[2]
  return(gene_range)
}

#' Paste two factors together and preserved their joint order.
#'
#' @param factor1 First factor
#' @param factor2 Second factor
#' 
#' @return Factors factor1 and factor2 pasted together.
pasteFactors <- function(factor1, factor2){
  #Extract levels
  levels1 = levels(factor1)
  levels2 = levels(factor2)
  
  #Construct joint levels
  new1 = rep(levels1, length(levels2))
  new2 = rep(levels2, each = length(levels1))
  new_levels = paste(new1, new2, sep = "_")
  
  new_factor = factor(paste(as.character(factor1), as.character(factor2), sep = "_"), levels = new_levels)
  return(new_factor)
}

# Calculate mean coverage within each track_id and colour_group
meanCoverage <- function(coverage_df){
  coverage_df = dplyr::group_by_(coverage_df, "track_id", "colour_group", "bins") %>% 
    dplyr::summarise_(.dots = stats::setNames(list(~mean(coverage)), c("coverage"))) %>%
    dplyr::ungroup() %>% # It's important to do ungroup before mutate, or you get unexpected factor results
    dplyr::mutate_(.dots = stats::setNames(list(~pasteFactors(as.factor(track_id), as.factor(colour_group))),c("sample_id")) ) #Construct a new sample id for mean vector
  
  return(coverage_df)
}

# Choose a subsample of points to make plotting faster
# Makes sure that intron-exon boundaries are well samples.
subsamplePoints <- function(tx_annotations, plot_fraction){
  #Define the start and end coorinates of the region
  region_start = min(IRanges::start(tx_annotations$new_introns))
  region_end = max(IRanges::end(tx_annotations$new_introns))
  region_length = region_end - region_start

  #Take a subsample of points that's easier to plot
  points = sample(region_length, floor(region_length*plot_fraction))
  #Subtract the start coordinate of the region
  exon_starts = unique(unlist(lapply(tx_annotations$exon_ranges, IRanges::start))) - (region_start -1)
  exon_ends = unique(unlist(lapply(tx_annotations$exon_ranges, IRanges::end))) - (region_start - 1)
  points = unique(sort(c(points, exon_starts, exon_ends, 
                         exon_starts -3, exon_starts +3, 
                         exon_ends + 3, exon_ends -3)))
  points = points[points >= 0]
  return(points)
}


#' Returns a three-colour palette suitable for visualising read coverage stratified by genotype
#'
#' @param old Return old colour palette (now deprecated).
#' @return Vector of three colours.
#' @export
#'
#' @examples
#' getGenotypePalette()
getGenotypePalette <- function(old = FALSE){
  if(old){
    c("#d7191c","#fdae61","#1a9641")
  } else{
    #Borrowed from Kumasaka, et al 2015
    c("#E9181D","#51BEEE","#18354B") 
  }
}

#Common theme for all data track plots
dataTrackTheme <- function(){
  theme = theme(axis.text.x = element_blank(), 
                axis.title.x = element_blank(), 
                axis.ticks.x = element_blank(),
                plot.margin=unit(c(0.1,1,0.1,1),"line"),
                legend.position="none",
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                strip.text.y = element_text(colour = "grey10"),
                strip.background = element_rect(fill = "grey85"))
  return(theme)
}

shortenIntrons <- function(introns, intron_length){
  #Shorten introns from a fixed length to a variable length
  
  #Calculate neccesary parameters
  exons = IRanges::gaps(introns)
  n_introns = length(introns)
  n_exons = length(exons)
  
  #Calculate cumulative with of introns
  intron_cum_width = seq(intron_length,(n_introns-1)*intron_length,intron_length)
  #Calculate new exon starts ignoring introns
  new_intron_starts = c(1,IRanges::start(introns)[2:n_introns] - (IRanges::end(introns)[1:n_introns-1] - intron_cum_width))
  #Add exon widths to the introns
  new_intron_starts = new_intron_starts + c(0,cumsum(IRanges::width(exons)) - IRanges::width(exons))
  
  new_introns = IRanges::IRanges(start = new_intron_starts, width = rep(intron_length, n_introns))
  return(new_introns)
}

shrinkIntronsCoverage <- function(coverage, old_introns, new_introns){
  
  #Covert coverage vector from Rle to normal vector
  coverage = S4Vectors::as.vector.Rle(coverage, mode = "double")

  #Calculate full annotations
  old_annot = S4Vectors::sort(c(old_introns, IRanges::gaps(old_introns)))
  new_annot = S4Vectors::sort(c(new_introns, IRanges::gaps(new_introns)))
  
  #If new and old annotations are identical then return coverage as data frame
  if(all(IRanges::width(old_annot) == IRanges::width(new_annot))){
    bins = seq(min(IRanges::start(new_annot)), max(IRanges::end(new_annot)))
   
    #Make sure that coverage vector and bins vector have equal length
    assertthat::assert_that(assertthat::are_equal(length(bins), length(coverage)))
    new_coverage = dplyr::data_frame(bins = bins, coverage = coverage)
    return(new_coverage)
    
  } else{ #Otherwise shrink intron converage
    
    #Calculate the width of each annotation bin
    bin_width = ceiling(IRanges::width(old_annot)/IRanges::width(new_annot))
    
    #Build summarisation groups
    s_coord = IRanges::start(new_annot)
    e_coord = IRanges::end(new_annot)
    w_old = IRanges::width(old_annot)
    
    bins = c()
    
    for (i in seq_along(new_annot)){
      bin_id = rep(c(s_coord[i]:e_coord[i]),each = bin_width[i])[1:w_old[i]]
      bins = c(bins, bin_id)
    }
    
    #Calculate mean coverage in bins
    df = data.frame(coverage, bins)
    new_coverage = dplyr::summarize(dplyr::group_by(df, bins), coverage = mean(coverage))
    return(new_coverage)
  }
}

translateExonCoordinates <- function(exons, old_introns, new_introns){
  #Tranlate exon coordinates by shortening introns
  old_exon_starts = IRanges::start(exons)
  old_intron_ends = IRanges::end(old_introns)
  new_intron_ends = IRanges::end(new_introns)
  
  #Translate old exon coordinates to new exon coordinates
  new_exon_starts = rep(0,length(old_exon_starts))
  for (i in seq_along(old_exon_starts)){
    #Find the nearest upstream intron for the current gene
    nearest_intron_number = max(which(old_exon_starts[i] > old_intron_ends))
    new_exon_starts[i] = old_exon_starts[i] - old_intron_ends[nearest_intron_number] + new_intron_ends[nearest_intron_number]
  }
  
  #Create new exon coordinates
  new_exons = IRanges::IRanges(start = new_exon_starts, width = IRanges::width(exons))
  return(new_exons)
}

rescaleIntrons <- function(exons, cdss, joint_exons, new_intron_length, flanking_length){
  
  #Convert exons and cds objects to ranges
  exon_ranges = lapply(exons, GenomicRanges::ranges)
  cds_ranges = lapply(cdss, GenomicRanges::ranges)
  
  #Shorten introns and translate exons into the new exons
  old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
  new_introns = shortenIntrons(old_introns,new_intron_length)
  new_exon_ranges = lapply(exon_ranges, translateExonCoordinates, old_introns, new_introns)
  new_cds_ranges = lapply(cds_ranges, translateExonCoordinates, old_introns, new_introns)
  
  return(list(exon_ranges = new_exon_ranges, cds_ranges = new_cds_ranges, 
              old_introns = old_introns, new_introns = new_introns))
}

plotTranscriptStructure <- function(exons_df, limits = NA, connect_exons = TRUE,  
                                    xlabel = "Distance from gene start (bp)", transcript_label = TRUE){
  
  #Extract the position for plotting transcript name
  transcript_annot = dplyr::group_by_(exons_df, ~transcript_id) %>% 
    dplyr::filter_(~feature_type == "exon") %>%
    dplyr::arrange_('transcript_id', 'start') %>%
    dplyr::filter(row_number() == 1)

  #Create a plot of transcript structure
  plot = ggplot(exons_df) + geom_blank()
  if(connect_exons){ #Print line connecting exons
    plot = plot + geom_line(aes_(x = ~start, y = ~transcript_rank, group = ~transcript_rank, color = ~feature_type))
  }
  plot = plot + 
    geom_rect(aes_(xmin = ~start, 
                   xmax = ~end, 
                   ymax = ~transcript_rank + 0.25, 
                   ymin = ~transcript_rank - 0.25, 
                   fill = ~feature_type)) + 
    theme_light() +
    theme(plot.margin=unit(c(0,1,1,1),"line"), 
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          legend.position="none",
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.text.y = element_text(colour = "grey10"),
          strip.background = element_rect(fill = "grey85")) +
    xlab(xlabel) +
    facet_grid(type~.) +
    scale_y_continuous(expand = c(0.2,0.15)) +
    scale_fill_manual(values = c("#2c7bb6","#abd9e9")) + 
    scale_colour_manual(values = c("#2c7bb6","#abd9e9"))
  if(all(!is.na(limits))){
    plot = plot + scale_x_continuous(expand = c(0,0)) +
      coord_cartesian(xlim = limits)
  }
  if(transcript_label){
    plot = plot + geom_text(aes_(x = ~start, 
                                 y = ~transcript_rank + 0.30, 
                                 label = ~transcript_label), 
                            data = transcript_annot, hjust = 0, vjust = 0, size = 4)

  }
  return(plot)
}

makeCoveragePlot <- function(coverage_df, limits, alpha, fill_palette, coverage_type){
  #Plot coverage over a region
  coverage_plot = ggplot(coverage_df, aes_(~bins, ~coverage, group = ~sample_id, alpha = ~alpha)) + 
    geom_blank() +
    theme_light()
  #Choose between plotting a line and plotting area
  if(coverage_type == "line"){
    coverage_plot = coverage_plot + 
      geom_line(aes_(colour = ~colour_group), alpha = alpha, position = "identity") 
  } else if (coverage_type == "area"){
    coverage_plot = coverage_plot + 
      geom_area(aes_(fill = ~colour_group), alpha = alpha, position = "identity")
  } else if (coverage_type == "both"){
    coverage_plot = coverage_plot + 
      geom_area(aes_(fill = ~colour_group), alpha = alpha, position = "identity") +
      geom_line(aes_(colour = ~colour_group), alpha = alpha, position = "identity") 
  } else{
    stop("Coverage type not supported.")
  }
  coverage_plot = coverage_plot +
    facet_grid(track_id~.) +
    dataTrackTheme() + 
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0)) +
    coord_cartesian(xlim = limits) +
    scale_color_manual(values = fill_palette) +
    scale_fill_manual(values = fill_palette) +
    ylab("FPM")
  return(coverage_plot)
}

#' Make a Manahattan plot of p-values
#' 
#' The Manhattan plots is compatible with wiggpleplotr read coverage and transcript strucutre plots. 
#' Can be appended to those using the cowplot::plot_grid() function. 
#'
#' @param pvalues_df Data frame of association p-values (required columns: track_id, p_nominal, pos)
#' @param region_coords Start and end coordinates of the region to plot. 
#' @param color_R2 Color the points according to R2 from the lead variant. Require R2 column in the pvalues_df data frame.
#' @param data_track If TRUE, then remove all information from x-axis. 
#' Makes it easy to append to read coverage or transcript strcture plots using cowplot::plot_grid(). 
#'
#' @return gglot2 object
#' @examples
#' data = dplyr::data_frame(track_id = "GWAS", pos = sample(c(1:1000), 200), p_nominal = runif(200, min = 0.0000001, 1))
#' makeManhattanPlot(data, c(1,1000), data_track = FALSE)
#' @export
makeManhattanPlot <- function(pvalues_df, region_coords, color_R2 = FALSE, data_track = TRUE){
  
  #Make assertions
  assertthat::assert_that(assertthat::has_name(pvalues_df, "track_id"))
  assertthat::assert_that(assertthat::has_name(pvalues_df, "p_nominal"))
  assertthat::assert_that(assertthat::has_name(pvalues_df, "pos"))
  
  #If R2 is specified
  if(color_R2){
    assertthat::assert_that(assertthat::has_name(pvalues_df, "R2"))
    plot_base = ggplot(pvalues_df, aes_(x = ~pos, y = ~-log(p_nominal, 10), colour = ~R2)) + geom_blank()
  } else{
    #Else do not colour
    plot_base = ggplot(pvalues_df, aes_(x = ~pos, y = ~-log(p_nominal, 10))) + geom_blank()
  }
  
  #Make the rest of the plot
  plot = plot_base + 
    facet_grid(track_id ~ .) +
    geom_point() + 
    theme_light() + 
    ylab(expression(paste("-",log[10], " p-value"))) +
    scale_x_continuous(expand = c(0,0)) +
    coord_cartesian(xlim = region_coords)
  
  #Apply data track theme so that plots can later be pasted together with cowplot
  if(data_track){
    plot = plot + dataTrackTheme()
  }
  return(plot)
}
## end
#####################

```

## Create bigWig Files

```{r create_bigwig, echo=F, eval=TRUE, warning=FALSE, result=F, include = F}
pos <- grep("/camp/stp", Obio@parameterList$AlignOutputEnsDir)

plotList <- list()
chnkVec <- as.vector(NULL, mode="character")
    

## Begin loop ##

for (i in 1:length(geneCoveragePlotVec)){
    chr <- unique(data[data$gene_name == geneCoveragePlotVec[i],"chromosome_name"])
    regionStart <- min(data[data$gene_name == geneCoveragePlotVec[i],"start_position"]) - 1000
    regionEnd   <- max(data[data$gene_name == geneCoveragePlotVec[i],"end_position"]) + 1000
    
    regionVar <- ""
    regionVar <- " -r chr8:78338395:80399518"
    regionVar <- paste0(" -r ",chr,":",regionStart,":",regionEnd)
    
    
    if (length(pos) == 0){
    Obio@parameterList$AlignOutputEnsDir <- paste0(
        workdir,
        "star_rsem/"
        )
    }
    
    bamFiles <- list.files(Obio@parameterList$AlignOutputEnsDir)
    bamFiles <- paste0(
        Obio@parameterList$AlignOutputEnsDir,
        bamFiles[grep("d.bam$", bamFiles)]
    )
    
    
    ## bam coverage can be limited to a chromosome or region with the --region flag
    # http://deeptools.readthedocs.io/en/develop/content/tools/bamCoverage.html#Optional%20arguments
    #Region of the genome to limit the operation to - this is useful when testing parameters to reduce the computing time. The format is chr:start:end, for example –region chr10 or –region chr10:456700:891000.
    
    cmdVec <- as.vector(NULL, mode="character")
    for (j in 1:length(bamFiles)){
        bwFN <- gsub(".bam", ".bw", bamFiles[j])
        newCmd <- paste0(
            'sbatch --time=02:00:00 --wrap "ml deepTools/2.5.3; bamCoverage -b ',bamFiles[j],' -o ',bwFN, regionVar ,' --binSize 20 --normalizeTo1x 130000000 --smoothLength 60 --extendReads 150 --centerReads
    " --job-name=$project --mem=40G -o BW',j,'.slurm >> commands.txt'
        )
        
        cmdVec <- c(
            cmdVec, 
            newCmd
        )
    }
    
    FNsh <- paste0(
        Obio@parameterList$workdir,
        Obio@parameterList$project_id,
        ".bigWig.conversion.script.sh"
    )
    
    
    writeSH <- function(FNsh, cmdVec){
      sink(file=FNsh)
          cat("#! /bin/sh");cat("\n");cat("\n");
          cat("project=BWCV");cat("\n");cat("\n");
          
          for (j in 1:length(cmdVec)){
              cat(cmdVec[j]);cat("\n");cat("\n");
          }
      sink()
        
    }
    
    
    writeSH(FNsh = FNsh, cmdVec=cmdVec)
    
    ## Create bigwig files and wait for result ##
    system(paste0("sh ", FNsh))
    
    ## check if bwfn exists ##
    bwFNall <- gsub(".bam", ".bw", bamFiles)
    oldbwFiles <- bwFNall[file.exists(bwFNall)]
    
    if (length(oldbwFiles) > 0){
        unlink(oldbwFiles)
    }
    
    fileExists <- rep(F, length(bwFNall))
    while( sum ( fileExists ) < length(bwFNall)){
        Sys.sleep(60)
        fileExists <- file.exists(bwFNall)
        print(paste0("Processing bigWig files: ", sum(fileExists), " out of ", length(bwFNall), " files processed."))
    }
    
    
    #############
    ## Do genomic plotting
    
    if (! is.null(Obio@parameterList$designTScol)){
        dfAnno <- unique(Obio@dfDesign[,c("sample.id", "sample.group", "sample.group_color", Obio@parameterList$designTScol)])
        dfAnno <- dfAnno[order(dfAnno[,Obio@parameterList$designTScol], decreasing = F),]
    } else {
      dfAnno <- unique(Obio@dfDesign[,c("sample.id", "sample.group", "sample.group_color")]) 
    }
    
    
    
    sampleVec <- unique(dfAnno$sample.id)
    sampleGroupVec <- dfAnno$sample.group
    sampleCols <- dfAnno$sample.group_color
    
    FNvec <- paste0(Obio@parameterList$AlignOutputEnsDir,sampleVec, ".markdup.sorted.bw")
    
    sizeFactors <- DESeq2::sizeFactors(Obio@ObjDds)
    sizeFactors <- sizeFactors[sampleVec]
    
    sample_data = dplyr::data_frame(
        sample_id = sampleVec, 
        condition = factor(sampleGroupVec, levels = unique(sampleGroupVec)), 
        scaling_factor = sizeFactors)
    
    library(dplyr)
    sample_data = sample_data %>%
        dplyr::mutate(bigWig = FNvec)

#as.data.frame(sample_data)





  

    selected_transcripts = transcript_metadata %>%
        dplyr::filter(gene_name == geneCoveragePlotVec[i])
    tx_ids = selected_transcripts$transcript_id
    gene_ids = selected_transcripts$gene_id
    # plotTranscripts(
    #     exons[tx_ids], cdss[tx_ids], 
    #     transcript_metadata, rescale_introns = TRUE)
    
    
    
    track_data = dplyr::mutate(sample_data, track_id = condition, colour_group = condition)
    
    #selected_transcripts = c("ENST00000438495", "ENST00000392477") #Plot only two transcripts of the gens
    
    
    tag <- paste0(geneCoveragePlotVec[i], "_Coverage")
    
    tx_ids_e <- tx_ids[tx_ids %in% names(exons)]
    
    
    tx_ids_c <- tx_ids[tx_ids %in% names(cdss)]
    
    if ((length(tx_ids_e) > 0) && (length(tx_ids_c) > 0)){
      
        plotList[[tag]] <- plotCoverage(
            exons = exons[tx_ids_e], 
            cdss = cdss[tx_ids_c], 
            transcript_metadata, 
            track_data,
            heights = c(2,1), 
            fill_palette = unique(sampleCols) ,
            rescale_introns = F,
            mean_only = FALSE, 
            alpha = 0.5,
            region_coords = c(regionStart, regionEnd)
        ) + theme(strip.text.y = element_text(size = 1)) # Change facet size on side
        
        
        FNbase <- paste0(tag, VersionPdfExt)
        FN <- paste0(Obio@parameterList$reportFigDir, FNbase)
        FNrel <- paste0("report_figures/", FNbase)
        
        pdf(FN)
            print(plotList[[tag]])
        dev.off()
        
        
        ## Create R markdown chunk ##
        figLegend <- paste0(
            "**Figure ",
            figureCount,
            ":** Gene Coverage Plot. ",
            "The gene coverage plot depicts the relative abundance of FPM values (fragments per million mapped fragments). The exon annotation underneath reflects the Ensembl annotation version used for the alignment of this RNA-Seq experiment. ",
                        "Download a pdf of this figure [here](", FNrel,"). "
        )
        
        
        figureCount <- figureCount + 1
        
        NewChnk <- paste0(
            "### ", tag,
            "\n```{r Gene_coverage", tag,
            ", results='asis', echo=F, eval=TRUE, warning=FALSE, fig.cap='",
            figLegend,"', fig.asp = 1, fig.align = 'center'}\n",
            "\n",
            "\n print(plotList[['",tag,"']])",
            "\n cat(  '\n')",
            "\n\n\n```\n"
        )
        
        
        chnkVec <- unique(c(
            chnkVec,
            NewChnk
        ))
        
        print(paste0(geneCoveragePlotVec[i], " done."))
    } else {
      print(paste0(geneCoveragePlotVec[i], " could not be processed."))
    }
}


if (length(plotList) > 3){
    tabVar <- ".tabset .tabset-fade .tabset-dropdown"
} else {
    tabVar <- ".tabset .tabset-fade .tabset-pills"
}

```

## Gene Coverage Plots {`r tabVar`}
The gene coverage plot depicts the relative abundance of FPM values (fragments per million mapped fragments). The exon annotation underneath reflects the Ensembl annotation version used for the alignment of this RNA-Seq experiment. 

```{r knit_cor_plot_characterization_plot, echo=TRUE, eval=TRUE, warning=FALSE, results="asis"}
cat(paste(knit(text = chnkVec, quiet = T), collapse = '\n'))
```

